# Factory Method vs Abtract Factory

Here's a **clear, side-by-side comparison** between **Factory Method** and **Abstract Factory** – perfect for interviews, exams, or real-world decisions.

| Feature                          | Factory Method                                      | Abstract Factory                                          |
|----------------------------------|-----------------------------------------------------|------------------------------------------------------------|
| **GoF Category**                 | Creational                                          | Creational                                                 |
| **Main Intent**                  | Let **subclasses** decide which **single** object to create | Create **families** of related objects without specifying their concrete classes |
| **Creates**                      | **One product** (e.g., a Button)                    | **Multiple related products** (e.g., Button + Checkbox + Scrollbar) |
| **Key Abstraction**              | One abstract method: `CreateButton()`               | One abstract factory interface with several methods: `CreateButton()`, `CreateCheckbox()` |
| **Number of factory methods**    | Usually **1** factory method                        | Usually **2+** factory methods                                     |
| **Typical use case**             | Platform-specific UI widget (Button only)           | Entire UI toolkit per platform (Button + Checkbox + Menu + …) |
| **Dependency direction**         | Client depends on **Creator** (Dialog)              | Client depends on **AbstractFactory** interface                    |
| **Extensibility**                | Add new product → add new ConcreteCreator           | Add new family (e.g., Linux) → add new ConcreteFactory             |
| **Can be implemented with**      | Abstract class or interface with one abstract method| Interface (or abstract class) with multiple abstract methods       |

### Visual Comparison

```text
Factory Method                              Abstract Factory
┌─────────────────┐                         ┌──────────────────────┐
│    Dialog       │                         │   IGUIFactory        │
│-----------------│                         │----------------------│
│ CreateButton()  │ ◄─────── One method      │ CreateButton()       │
└─────────────────┘                         │ CreateCheckbox()     │
      /         \                            │ CreateScrollbar()    │
WindowsDialog   MacDialog                   └──────────────────────┘
      \           /                                /          \
  returns WindowsButton                        WindowsFactory   MacFactory
                                                   \            /
                                        returns whole family of widgets
```

### Real-World Example Side by Side

| Scenario                               | Factory Method (Good)                                 | Abstract Factory (Better)                                      |
|----------------------------------------|-------------------------------------------------------|-----------------------------------------------------------------|
| Cross-platform Button only             | Yes, `Dialog.CreateButton()`                          | Overkill                                                        |
| Full UI toolkit (Button + Checkbox + Menu) | You would need many parallel Factory Methods          | Yes, `GUIFactory` creates the whole consistent family          |
| Game with different themes (Modern, Retro, Fantasy) | One factory method per weapon type (not ideal)       | Yes, `ThemeFactory` creates Sword + Shield + Armor of same theme |

### Code Comparison (C#)

```csharp
// Factory Method – creates ONE product
public abstract class Dialog
{
    public abstract IButton CreateButton();   // Only one
}

// Abstract Factory – creates a FAMILY of products
public interface IGUIFactory
{
    IButton     CreateButton();
    ICheckbox   CreateCheckbox();
    IScrollBar  CreateScrollBar();
    IMenu       CreateMenu();
}

public class WindowsFactory : IGUIFactory { ... }
public class MacFactory     : IGUIFactory { ... }
```

### Decision Table – Which One to Use?

| Your Need                                              | Use This Pattern         |
|--------------------------------------------------------|--------------------------|
| You only need to create **one** kind of object        | **Factory Method**       |
| You need to create **several related** objects together| **Abstract Factory**     |
| You add new platforms often (Windows → Linux → Web)    | Factory Method is simpler|
| You add new widget types often (new ScrollBar, Slider) | Abstract Factory scales better |
| You want maximum simplicity                            | Factory Method           |
| You want consistent object families (no mix & match)   | Abstract Factory         |

### Quick Mnemonic

- **Factory Method** = “One product, many variants” → **One factory method**
- **Abstract Factory** = “Many related products, many variants” → **One factory interface with many methods**

Both patterns are often used **together** in real applications!  
Example: A `WindowsDialog` (Factory Method) gets injected a `WindowsGUIFactory` (Abstract Factory) to create its child controls.

Now you can confidently explain the difference in any interview!